[
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "4e61e200-d9ed-4bc7-9352-9ff74e244fad",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC001-User Signup with Email Verification",
    "description": "Verify that a new user can sign up successfully, receive an email verification, and access protected routes only after verification.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Look for any navigation or links to the signup page, possibly by scrolling or checking for hidden elements.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Email verification failed: user not verified').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The user did not receive the expected email verification prompt or the verification process did not complete successfully, preventing access to protected routes as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The signup page or link is missing on the main page at http://localhost:5173. Therefore, the signup flow cannot be tested. The user cannot sign up, receive email verification, or access protected routes as the signup functionality is not accessible. Please fix the website to include a signup page or link to proceed with testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Dashboard.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Calls.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Leads.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Payments.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/176194560190946//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.512Z",
    "modified": "2025-10-31T21:20:02.054Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "b78c65cf-a9b4-4a78-b546-366eb674c910",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC002-Login with Correct Credentials",
    "description": "Verify that the user can log in successfully with valid credentials and access protected application areas.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find a login page or login link/button to proceed to login.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to find any login link or button by scrolling further or checking for navigation elements.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful! Welcome to your dashboard').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User login was not successful or dashboard was not reached as expected based on the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Login page is not accessible. Navigations to the base URL and /login URL lead to error pages, preventing login testing and verification of login functionality.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Login.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Calls.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Leads.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Payments.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945610267571//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.521Z",
    "modified": "2025-10-31T21:20:10.397Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "fac3e6d4-2d7e-407a-9f07-a0e3ad3770c7",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC003-Login Failure with Incorrect Password",
    "description": "Verify that login fails when an incorrect password is provided and appropriate error message is shown.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Login Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Login should fail with incorrect password and display an error message indicating invalid credentials, but the success message was found instead.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The login page is not accessible because the local server at http://localhost:5173 is down or not responding. Therefore, the test to verify login failure with incorrect password cannot be performed. Please ensure the local server is running and accessible, then retry the test.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Dashboard.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Payments.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Settings.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/AgentSetup.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945646154//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.526Z",
    "modified": "2025-10-31T21:20:46.282Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "93934636-a281-4751-98eb-cb9c10cac855",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC004-Password Reset Workflow",
    "description": "Verify the password reset flow, including email request, email receipt, and password change completion.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Password Reset Successful! Welcome Back').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The password reset flow did not complete successfully as expected. The password reset email might not have been sent, the reset link might not have worked, or the new password was not accepted. Please verify the entire password reset process including email request, receipt, and password change completion.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945655108698//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.531Z",
    "modified": "2025-10-31T21:20:55.265Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "bd01af29-2c9e-4b4f-8bfc-3c8639b3b651",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC005-Voice AI Assistant Inbound Call Handling",
    "description": "Verify the Voice AI Assistant answers calls 24/7, performs real-time transcription, supports voice selection, and handles errors gracefully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=AI Voice Assistant is offline').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The Voice AI Assistant did not answer calls 24/7, perform real-time transcription, support voice selection, or handle errors gracefully as required by the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The Voice AI Assistant interface is not accessible as the browser is currently at about:blank with no UI elements to interact with. Unable to proceed with the simulation of incoming calls, voice selection changes, error handling, or transcription verification. Please provide the correct URL or environment details to continue testing.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Home.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Terms.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Login.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945625599355//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.537Z",
    "modified": "2025-10-31T21:20:25.736Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "4007b95a-f726-47c6-a112-10c95717c3b1",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC006-AI Chat Widget Interaction with Emotion Detection",
    "description": "Validate the AI Chat Widget provides contextual responses, detects user emotions, and tracks conversation quality accurately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authentication Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The AI Chat Widget did not provide contextual responses, detect user emotions, or track conversation quality as expected. Authentication flow and password reset routes verification failed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/AgentSetup.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/176194565593037//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.542Z",
    "modified": "2025-10-31T21:20:56.065Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "c88a80f9-e5f9-443f-9c2f-25b9a95c34ca",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC007-Lead Management System Captures and Qualifies Leads",
    "description": "Confirm that lead information auto-extracted from calls and chats is stored properly with accurate qualification status updates.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Lead Information Successfully Extracted and Stored').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Lead information auto-extraction and qualification status update did not complete successfully as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945653916147//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.546Z",
    "modified": "2025-10-31T21:20:54.058Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "a4a92fa6-5e59-445c-8e1f-7ef977dd0673",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC008-Dashboard Displays Accurate Analytics and Call Logs",
    "description": "Verify the Dashboard correctly renders stats cards, charts, call logs, lead data, and payment history reflecting the backend data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click login or dashboard navigation to proceed to dashboard\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to find login or dashboard navigation by scrolling or checking for hidden elements\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Dashboard Overview - Comprehensive Stats').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Dashboard did not render stats cards, charts, call logs, lead data, and payment history as expected based on the backend data.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The main page is empty with no login or navigation elements visible, so I cannot proceed with the dashboard verification task. Please check the application state or provide access to the login/dashboard page.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Settings.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/AgentSetup.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/EmailVerification.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/PasswordReset.tsx:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/176194560908415//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.552Z",
    "modified": "2025-10-31T21:20:09.211Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "166dcc64-a802-479c-8696-6364b7b70c5c",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC009-Subscription Payment Processing via Flutterwave",
    "description": "Verify subscription management, payment links generation, secure billing workflows and proper response handling with Flutterwave integration.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Subscription Plan Activated Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Subscription management and payment workflows with Flutterwave integration did not complete successfully as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application at localhost:5173 is not loading and results in a browser error page with no interactive elements. Due to this, I cannot proceed with verifying subscription management, payment link generation, secure billing workflows, or response handling with Flutterwave integration. Please ensure the application server is running and accessible, then retry the testing process.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Privacy.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Terms.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Login.tsx:0:0)\n[WARNING] [GroupMarkerNotSet(crbug.com/242999)!:A0C44E0044000000]Automatic fallback to software WebGL has been deprecated. Please use the --enable-unsafe-swiftshader flag to opt in to lower security guarantees for trusted content. (at http://localhost:5173/:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&display=swap:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945927056133//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.557Z",
    "modified": "2025-10-31T21:25:27.180Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "ac3c08d5-6b09-4882-bc75-e22bebc12261",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC010-Agent Setup and AI Assistant Configuration",
    "description": "Verify users can configure AI assistant voice models, parameters, custom instructions, and perform test calls reflecting applied settings.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Voice Model Configuration Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test call did not behave according to the new settings with accurate voice and behavior as expected in the AI assistant configuration.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The app is not reachable at the provided URL, showing a browser error page. Please provide a correct or accessible URL to continue testing the AI assistant voice model configuration and test call functionality.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@vite/client:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/main.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@react-refresh:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945623123471//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.561Z",
    "modified": "2025-10-31T21:20:23.244Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "20a5f582-0bb1-400d-bf3d-6d3b8be82ddf",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC011-Telegram Notification for Real-time Lead Alerts",
    "description": "Verify that new leads trigger real-time notifications sent to users via the integrated Telegram bot with correct lead details.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Check if there is any way to simulate new lead capture from call or chat, or if I need to navigate to another page or open a menu to do so.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Look for navigation menus, links, or buttons to access lead capture simulation or related settings.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Click on 'Sign In' to attempt to log in and access user dashboard or settings for lead capture simulation.\n        frame = context.pages[-1]\n        # Click on 'Sign In' link to access login page\n        elem = frame.locator('xpath=html/body/div/div/nav/div/div/div[3]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input valid email and password, then click the 'Sign In' button to log in.\n        frame = context.pages[-1]\n        # Input email for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('testuser@example.com')\n        \n\n        # -> Input password 'TestPassword123' into the password field and click the 'Sign In' button to log in.\n        frame = context.pages[-1]\n        # Input password for login\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/div[2]/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('TestPassword123')\n        \n\n        frame = context.pages[-1]\n        # Click the 'Sign In' button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/div/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Lead Notification Received').first).to_be_visible(timeout=5000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: New leads did not trigger real-time notifications via the Telegram bot with correct lead details as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Unable to verify that new leads trigger real-time notifications via the integrated Telegram bot because the application backend or network is not accessible. Login attempts fail with 'Failed to fetch' errors, and navigation to API endpoints results in browser errors. No UI elements are available to simulate new lead capture or verify notifications. Please check backend services and network connectivity before retrying.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Dashboard.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Calls.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Leads.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Payments.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/pages/Settings.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;500;600;700;800;900&display=swap:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/logo.jpeg:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/1.png:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/2.png:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/3.png:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/4.png:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/images/logo.jpeg:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at https://bcufohulqrceytkrqpgd.supabase.co/auth/v1/token?grant_type=password:0:0)\n[ERROR] TypeError: Failed to fetch\n    at http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6565:23\n    at _handleRequest3 (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6835:20)\n    at _request (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6825:22)\n    at SupabaseAuthClient.signInWithPassword (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:8500:21)\n    at signIn (http://localhost:5173/src/contexts/AuthContext.tsx:83:40)\n    at handleSubmit (http://localhost:5173/src/pages/Login.tsx:40:17)\n    at HTMLUnknownElement.callCallback2 (http://localhost:5173/node_modules/.vite/deps/chunk-EM6PUTC5.js?v=801c9715:3680:22)\n    at Object.invokeGuardedCallbackDev (http://localhost:5173/node_modules/.vite/deps/chunk-EM6PUTC5.js?v=801c9715:3705:24)\n    at invokeGuardedCallback (http://localhost:5173/node_modules/.vite/deps/chunk-EM6PUTC5.js?v=801c9715:3739:39)\n    at invokeGuardedCallbackAndCatchFirstError (http://localhost:5173/node_modules/.vite/deps/chunk-EM6PUTC5.js?v=801c9715:3742:33) (at http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6836:12)\n[ERROR] Login error: AuthRetryableFetchError: Failed to fetch\n    at _handleRequest3 (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6838:11)\n    at async _request (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:6825:16)\n    at async SupabaseAuthClient.signInWithPassword (http://localhost:5173/node_modules/.vite/deps/@supabase_supabase-js.js?v=801c9715:8500:15)\n    at async signIn (http://localhost:5173/src/contexts/AuthContext.tsx:83:20)\n    at async handleSubmit (http://localhost:5173/src/pages/Login.tsx:40:11) (at http://localhost:5173/src/pages/Login.tsx:56:14)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/176194593456928//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.566Z",
    "modified": "2025-10-31T21:25:34.689Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "27c56564-3a72-454c-b7c4-a09fecfa2722",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC012-Role-Based Access Control and Row Level Security Enforcement",
    "description": "Ensure that user roles restrict access to protected routes and data in compliance with the security policies including RLS and JWT authentication.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Admin Dashboard').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: User roles did not restrict access properly. Standard users should not see 'Access Granted to Admin Dashboard', indicating a failure in enforcing RLS and JWT authentication policies.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/main.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@react-refresh:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/node_modules/.pnpm/vite@6.2.6_@types+node@22.14.1_jiti@1.21.7_yaml@2.7.1/node_modules/vite/dist/client/env.mjs:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945664781792//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.572Z",
    "modified": "2025-10-31T21:21:04.911Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "07a083c6-92eb-402a-ad22-f2fdef40828a",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC013-Error Boundary Component Handling UI Errors Gracefully",
    "description": "Verify that when JavaScript errors occur in the UI components, the error boundary catches them and displays user-friendly error messages without crashing.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Unexpected JavaScript error occurred in component').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The error boundary did not catch the JavaScript error and display a user-friendly message as expected. The application may have crashed or failed to handle the error gracefully.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: net::ERR_EMPTY_RESPONSE at http://localhost:5173/\nCall log:\n  - navigating to \"http://localhost:5173/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945556986865//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.577Z",
    "modified": "2025-10-31T21:19:17.100Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "1442a58a-d72b-4356-9db8-430edc0ef0bc",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC014-Landing Page Renders Correctly and Responsive",
    "description": "Check all sections of the premium marketing landing page render properly and adapt to different screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Authentication Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The premium marketing landing page did not render all required sections properly or adapt to different screen sizes as expected. Authentication flow and related routes verification also failed.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/main.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@react-refresh:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945655311781//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.582Z",
    "modified": "2025-10-31T21:20:55.439Z"
  },
  {
    "projectId": "8bb27355-e98f-42f9-89da-eb90a48512ad",
    "testId": "d429f96c-bb0b-4005-a55c-7e275f3d011c",
    "userId": "84a8b4a8-a0d1-7017-52a7-7374cabeb821",
    "title": "TC015-Design System Consistency Across UI Components",
    "description": "Ensure typography, color palette, and premium shadows are applied consistently in accordance with the design system guidelines across all pages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Comic Sans MS is the primary font').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: Typography, color palette, and premium shadows are not consistently applied as per design system guidelines across all pages.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application pages are not accessible due to a browser error page. Verification of typography, color palette, and premium shadows could not be performed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@vite/client:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/src/main.tsx:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5173/@react-refresh:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/84a8b4a8-a0d1-7017-52a7-7374cabeb821/1761945621206333//tmp/test_task/result.webm",
    "created": "2025-10-31T21:18:47.587Z",
    "modified": "2025-10-31T21:20:21.329Z"
  }
]
